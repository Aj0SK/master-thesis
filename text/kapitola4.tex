\chapter{Implementation and benchmarking}
\label{kap:kap4}

In this chapter, we focus on implementation of the ideas from previous chapter.
First, we describe the important parts and decisions in our implementation. Then,
we describe how we benchmarked our implementation and the results we obtained.

\section{Implementation}

We decided to make our solution a part of the SDSL library~\citep{gog2014theory}. This
is of the most matured and versatile libraries implementing succinct data structures.
SDSL is a heavily tested library offering various implementations of succinct
structures such as wavelet tree, FM-index, bit vectors, suffix array and many more.
It allows to easily use different building blocks to implement more complex structures,
i.e. using different bit vector implementations in wavelet tree. On top of this, thorough
tests and benchmarks were devised and used, mainly by \cite{gog2014optimized}.

\section{Benchmarking}

We benchmarked our code using 3 types of benchmarks. The first type of the bechmarks
were the micro-benchmarks, focusing on measuring the performance of block encoding
and decoding in more artificial setting. The second type of benchmarks was based on
the SDSL benchmarks mainly focusing on the performance of the bit vector but also
on the performance of FM-index when the bit vector is used inside of the FM-index.

\paragraph{Bit vector in FM-index}
Most of the FM-index implementations provide at least methods:
\begin{itemize}
	\item $\mathit{count}(P)$ counts the number of occurrences of $P$ in text $T$
	\item $\mathit{locate}(P)$ returns all positions of pattern $P$ in text $T$
	\item $\mathit{extract}(i, j)$ returns the subsequence $T[i..j]$
\end{itemize}
The reason that the $\mathit{extract}$ method is useful and non-trivial is that FM-index
does not store the original sequence $T$ -- at least not in an easily readable form.
As we have already shown, the bit vector is used in the implementation of the FM-index as it is
used inside of the wavelet tree as was described in section TODO.