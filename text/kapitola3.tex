\chapter{Our work}
\label{kap:kap3}

In this chapter, we shall look into our new proposals to enhance the existing implementation of RRR.

\section{Block encoding}

As we already discussed in Section~\ref{section:compressed_bv}, there are to the best of our knowledge two
widely used methods to encode and decode the block in RRR. The main problem of the table decoding method
is the big space overhead space it is using and the inability to support a bigger block size in practice resulting from the huge table
sizes for bigger block length. On the other hand, the on-the-fly decoding can be used to support a bigger
block size with the downside being longer encoding and decoding times. We shall now propose new way of
encoding and decoding the blocks. The objective of the new method is to create an alternative to the
previous methods that enables a longer block size while not hurting the runtime so significantly.

The main idea behind our solution is to use a divide-and-conquer approach to break the problem of finding the order of the block
$B$ along the class $c$. This will in turn enable us to use the table method to solve the smaller subproblems.
To facilitate our solution, we need to alter the respective order of the blocks along the same class. In our solution, we also use
the number of ones to identify the class of block. The previous solutions used the lexicographical ordering for the blocks that
shared the same class. In our solution, every block $B$ will be thought of as two smaller blocks of half the size $B_1$ and $B_2$.
We shall at first sort by the pair $(c_1, c_2)$ and then, subsequently by $B_1$ and $B_2$ where $c_1$ and $c_2$ are the respective
classes of the smaller blocks. Note that the original lexicographical ordering can be rephrased in the context of sub-blocks as
sorting at first by $B_1$ and then by $B_2$. The example of the ordering can be found in Figure~\ref{obr:lexicographicalVsUs}.

\begin{figure}
	\centerline{
        \begin{tabular}{l c l}
            Offset  &   Block       & $(c_1, c_2)$\\
        \hline
            \small 0&   \tt 000 011 & \multirow{3}{*}{$(0, 1)$}\\
            \small 1&   \tt 000 101 & \\
            \small 2&   \tt 000 110 & \\
        \hline
            \small 3&   \tt 001 001 & \multirow{5}{*}{$(1, 1)$}\\
            \small 4&   \tt 001 010 &\\
            \small 5&   \tt 001 100 &\\
            \small 6&   \tt 010 001 &\\
            \small 7&   \tt 010 010 &\\
        \end{tabular}
        \hspace{3em}
        \begin{tabular}{l c l}
            \small 8&   \tt 010 100 & \multirow{4}{*}{$(1, 1)$}\\
            \small 9&   \tt 100 001 &\\
            \small 10&  \tt 100 010 &\\
            \small 11&  \tt 100 100 & \\
        \hline
            \small 12&  \tt 011 000 & \multirow{3}{*}{$(2, 0)$}\\
            \small 13&  \tt 101 000 &\\
            \small 14&  \tt 110 000 &\\
        \end{tabular}
	}
	\caption[TODO]{
        Example of the new ordering for the block length $b=6$ and class $c=2$.
        Every block is divided into two sub-blocks of size 3. Note the differences to the
        lexicographical ordering. Block {\tt 011 000} on offset 12 is preceded by lexicographicaly
        greater blocks {\tt 100 001}, {\tt 100 010} and {\tt 100 100} as it has bigger number of ones
        in the first sub-block.
    }
	\label{obr:lexicographicalVsUs}
\end{figure}

We shall now show how we use this new ordering and that it is convenient to encode and decode $B$ in a divide and conquer manner.

\paragraph{Encoding}

At first, we shall look at the example of the encoding and then we will the generalize the ideas behind
the process. Imagine a block {\tt 100 010} we want to encode. We can easily see that the class of this
block is $c=2$ as there are two ones in the block. Obtaining the offset is harder. We will enumerate the
number of smaller blocks in the class $c=2$. There are three categories of blocks preceding {\tt 100 010}:

\begin{itemize}
    \item Blocks with the smaller number of ones in the first sub-block.
    (There are 3 such blocks -- those beginning with {\tt 000}.)
    \item Blocks with the same number of ones in the first sub-block, but smaller first and second sub-block.
    (There are 6 blocks with this property -- those beginning with {\tt 010} or {\tt 001}.)
    \item Blocks with the same first sub-block , but smaller second sub-block.
    (There is 1 such block, namely {\tt 100 001}.)
\end{itemize}

Summing up, we get that there are 10 blocks preceding {\tt 100 010} so it has the offset $o=10$. Together
with class we would encode this block as a pair $(2, 10)$. 

In general, consider a block $B$ of length $b$. The first step is to obtain $c$ -- the class of the block,
this can be easily done by counting ones in $B$. To obtain the sequence number of $B$ in class $c$, we shall
count the number of blocks preceding $B$. There are three groups of blocks preceding $B$:

\begin{enumerate}
    \item Blocks with the first sub-block having smaller class than $B_1$. \label{chapter3:encoding:1}
    \item Blocks with the first sub-block being of the same class as is $B_1$ but with smaller first sub-block. \label{chapter3:encoding:2}
    \item Blocks with the same first sub-block but smaller second sub-block. \label{chapter3:encoding:3}
\end{enumerate}

The number of blocks in group~\ref{chapter3:encoding:1} is equal to
$$\sum_{i=0}^{c_1-1} {15\choose i} {15\choose c-i}$$ where $i$ denotes the number of ones in the first
block. the number of ways how the first and second block may
look respectively. Terms ${15\choose i}$ and ${15\choose c-i}$ denotes the number of ways how the
$i$-th block may look if there is $i$-ones in the first sub-block and the rest -- $c-i$ ones in the
second sub-block.

The number of blocks in the group~\ref{chapter3:encoding:2} is equal to the number of blocks that
share classes of sub-blocks, but are smaller than $B$. Number of these blocks is $o_1\times {15\choose c_1}$.

The number of blocks in the group~\ref{chapter3:encoding:3} is equal to the number of blocks smaller 
than $B_2$. This is identical to the offset $o_2$. 

So everything we need to obtain the offset of $B$ is $(c_1, o_1)$ and $(c_2, o_2)$ -- this can be computed
recursively.

\paragraph{Decoding}

Decoding is a process of obtaining block $B$ from pair $(c, o)$. Obtaining $c$ is trivial as we need
only to count the number of ones in $B$. Then, we would like to use our sub-routines for the blocks
of size $b/2$. Hovewer to use these we need to find what the classes and offsets are of the smaller
blocks. Namely, we need to find what the pairs $(c_1, o_1)$ and $(c_2, o_2)$ are. To obtain these
pairs we need to find out what are the number of blocks in the groups \ref{chapter3:encoding:1},
\ref{chapter3:encoding:2} and \ref{chapter3:encoding:3}. To simplify, we will define $C_i$ to be a 
number of blocks of length $b$ with less than or equal number of ones in the first block than $i$.
We then compute the values of $C_i$ for every $i$ ($0\leq i\leq c$). Note that from the definition
$C_i = \sum_{j=0}^{i} {15 \choose j} {15 \choose c-j}$. To found $c_1$ we need to basically find the
biggest $C_{max}$ such that $o<C_{max}$. After finding it, we know that $c_1 = max+1$ and that
$c_2 = c - c_1$. Problem is that number of elements from group~\ref{chapter3:encoding:2} and
\ref{chapter3:encoding:3} is in total equal to $C_{max}-o$ but we do not know the exact number
of the elements in the respective group yet. Hovewer, we know the number of ones in each sub-block,
so we need to just get a respective $o_1$ and $o_2$ to again use our table decoding subroutine. We
know that $C_{max}-o = {15 \choose c_2} + x$.

\section{Hybrid encoding}